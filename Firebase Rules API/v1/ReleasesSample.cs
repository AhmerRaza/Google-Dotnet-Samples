// Copyright 2017 DAIMTO :  www.daimto.com
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
// the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
// an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by DAIMTO-Google-apis-Sample-generator 1.0.0
//     Template File Name:  Methodtemplate.tt
//     Build date: 01/02/2017 22:32:51
//     C# generater version: 1.0.0
//     
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
  
// About 
// 
// Unoffical sample for the FirebaseRulesAPI v1 API for C#. 
// This sample is designed to be used with the Google .Net client library. (https://github.com/google/google-api-dotnet-client)
// 
// API Description: Creates and manages rules that determine when a Firebase Rules-enabled service should permit a request.

// API Documentation Link https://firebase.google.com/docs/storage/security
//
// Discovery Doc  https://www.googleapis.com/discovery/v1/apis/FirebaseRulesAPI/v1/rest
//
//------------------------------------------------------------------------------
// Installation
//
// This sample code uses the Google .Net client library 
//
// NuGet package:
//
// Location: https://www.nuget.org/packages/Google.Apis.FirebaseRulesAPI.v1/ 
// Install Command: PM>  Install-Package Google.Apis.FirebaseRulesAPI.v1
//
//------------------------------------------------------------------------------  
using Google.Apis.FirebaseRulesAPI.v1;
using Google.Apis.FirebaseRulesAPI.v1.Data;
using System;

namespace GoogleSamplecSharpSample.FirebaseRulesAPIv1.Methods
{
  
    public static class ReleasesSample
    {


        /// <summary>
        /// Update a `Release`.

Only updates to the `ruleset_name` field will be honored. `Release` rename
is not supported. To create a `Release` use the CreateRelease method
instead. 
        /// Documentation https://developers.google.com/firebaserulesapi/v1/reference/releases/update
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated FirebaseRulesAPI service.</param>  
        /// <param name="name">Resource name for the `Release`.

`Release` names may be structured `app1/prod/v2` or flat `app1_prod_v2`
which affords developers a great deal of flexibility in mapping the name
to the style that best fits their existing development practices. For
example, a name could refer to an environment, an app, a version, or some
combination of three.

In the table below, for the project name `projects/foo`, the following
relative release paths show how flat and structured names might be chosen
to match a desired development / deployment strategy.

Use Case     | Flat Name           | Structured Name
-------------|---------------------|----------------
Environments | releases/qa         | releases/qa
Apps         | releases/app1_qa    | releases/app1/qa
Versions     | releases/app1_v2_qa | releases/app1/v2/qa

The delimiter between the release name path elements can be almost anything
and it should work equally well with the release name list filter, but in
many ways the structured paths provide a clearer picture of the
relationship between `Release` instances.

Format: `projects/{project_id}/releases/{release_id}`</param>
        /// <param name="body">A valid FirebaseRulesAPI v1 body.</param>
        /// <returns>ReleaseResponse</returns>
        public static Release Update(FirebaseRulesAPIService service, string name, Release body)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (name == null)
                    throw new ArgumentNullException(name);

                // Make the request.
                return service.Releases.Update(body, name).Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Releases.Update failed.", ex);
            }
        }


        /// <summary>
        /// Create a `Release`.

Release names should reflect the developer's deployment practices. For
example, the release name may include the environment name, application
name, application version, or any other name meaningful to the developer.
Once a `Release` refers to a `Ruleset`, the rules can be enforced by
Firebase Rules-enabled services.

More than one `Release` may be 'live' concurrently. Consider the following
three `Release` names for `projects/foo` and the `Ruleset` to which they
refer.

Release Name                    | Ruleset Name
--------------------------------|-------------
projects/foo/releases/prod      | projects/foo/rulesets/uuid123
projects/foo/releases/prod/beta | projects/foo/rulesets/uuid123
projects/foo/releases/prod/v23  | projects/foo/rulesets/uuid456

The table reflects the `Ruleset` rollout in progress. The `prod` and
`prod/beta` releases refer to the same `Ruleset`. However, `prod/v23`
refers to a new `Ruleset`. The `Ruleset` reference for a `Release` may be
updated using the UpdateRelease method, and the custom `Release` name
may be referenced by specifying the `X-Firebase-Rules-Release-Name` header. 
        /// Documentation https://developers.google.com/firebaserulesapi/v1/reference/releases/create
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated FirebaseRulesAPI service.</param>  
        /// <param name="name">Resource name for the project which owns this `Release`.

Format: `projects/{project_id}`</param>
        /// <param name="body">A valid FirebaseRulesAPI v1 body.</param>
        /// <returns>ReleaseResponse</returns>
        public static Release Create(FirebaseRulesAPIService service, string name, Release body)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (body == null)
                    throw new ArgumentNullException("body");
                if (name == null)
                    throw new ArgumentNullException(name);

                // Make the request.
                return service.Releases.Create(body, name).Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Releases.Create failed.", ex);
            }
        }


        /// <summary>
        /// Get a `Release` by name. 
        /// Documentation https://developers.google.com/firebaserulesapi/v1/reference/releases/get
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated FirebaseRulesAPI service.</param>  
        /// <param name="name">Resource name of the `Release`.


Format: `projects/{project_id}/releases/{release_id}`</param>
        /// <returns>ReleaseResponse</returns>
        public static Release Get(FirebaseRulesAPIService service, string name)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (name == null)
                    throw new ArgumentNullException(name);

                // Make the request.
                return service.Releases.Get(name).Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Releases.Get failed.", ex);
            }
        }

        public class ReleasesListOptionalParms
        {
            /// Page size to load. Maximum of 100. Defaults to 10.
Note: `page_size` is just a hint and the service may choose to load less
than `page_size` due to the size of the output. To traverse all of the
releases, caller should iterate until the `page_token` is empty.
            public int PageSize { get; set; }  
            /// `Release` filter. The list method supports filters with restrictions on the
`Release` `name` and also on the `Ruleset` `ruleset_name`.

Example 1) A filter of 'name=prod*' might return `Release`s with names
within 'projects/foo' prefixed with 'prod':

Name                          | Ruleset Name
------------------------------|-------------
projects/foo/releases/prod    | projects/foo/rulesets/uuid1234
projects/foo/releases/prod/v1 | projects/foo/rulesets/uuid1234
projects/foo/releases/prod/v2 | projects/foo/rulesets/uuid8888

Example 2) A filter of `name=prod* ruleset_name=uuid1234` would return only
`Release` instances for 'projects/foo' with names prefixed with 'prod'
referring to the same `Ruleset` name of 'uuid1234':

Name                          | Ruleset Name
------------------------------|-------------
projects/foo/releases/prod    | projects/foo/rulesets/1234
projects/foo/releases/prod/v1 | projects/foo/rulesets/1234

In the examples, the filter parameters refer to the search filters for
release and ruleset names are relative to the project releases and rulesets
collections. Fully qualified prefixed may also be used. e.g.
`name=projects/foo/releases/prod* ruleset_name=projects/foo/rulesets/uuid1`
            public string Filter { get; set; }  
            /// Next page token for the next batch of `Release` instances.
            public string PageToken { get; set; }  
        
        }
 
        /// <summary>
        /// List the `Release` values for a project. This list may optionally be
filtered by `Release` name or `Ruleset` id or both. 
        /// Documentation https://developers.google.com/firebaserulesapi/v1/reference/releases/list
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated FirebaseRulesAPI service.</param>  
        /// <param name="name">Resource name for the project.

Format: `projects/{project_id}`</param>
        /// <param name="optional">Optional paramaters.</param>        /// <returns>ListReleasesResponseResponse</returns>
        public static ListReleasesResponse List(FirebaseRulesAPIService service, string name, ReleasesListOptionalParms optional = null)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (name == null)
                    throw new ArgumentNullException(name);

                // Building the initial request.
                var request = service.Releases.List(name);

                // Applying optional parameters to the request.                
                request = (ReleasesResource.ListRequest)SampleHelpers.ApplyOptionalParms(request, optional);

                // Requesting data.
                return request.Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Releases.List failed.", ex);
            }
        }


        /// <summary>
        /// Delete a `Release` by resource name. 
        /// Documentation https://developers.google.com/firebaserulesapi/v1/reference/releases/delete
        /// Generation Note: This does not always build corectly.  Google needs to standardise things I need to figuer out which ones are wrong.
        /// </summary>
        /// <param name="service">Authenticated FirebaseRulesAPI service.</param>  
        /// <param name="name">Resource name for the `Release` to delete.

Format: `projects/{project_id}/releases/{release_id}`</param>
        /// <returns>EmptyResponse</returns>
        public static Empty Delete(FirebaseRulesAPIService service, string name)
        {
            try
            {
                // Initial validation.
                if (service == null)
                    throw new ArgumentNullException("service");
                if (name == null)
                    throw new ArgumentNullException(name);

                // Make the request.
                return service.Releases.Delete(name).Execute();
            }
            catch (Exception ex)
            {
                throw new Exception("Request Releases.Delete failed.", ex);
            }
        }

        
	}
		public static class SampleHelpers
    {

        /// <summary>
        /// Using reflection to apply optional parameters to the request.  
        /// 
        /// If the optonal parameters are null then we will just return the request as is.
        /// </summary>
        /// <param name="request">The request. </param>
        /// <param name="optional">The optional parameters. </param>
        /// <returns></returns>
        public static object ApplyOptionalParms(object request, object optional)
        {
            if (optional == null)
                return request;

            System.Reflection.PropertyInfo[] optionalProperties = (optional.GetType()).GetProperties();

            foreach (System.Reflection.PropertyInfo property in optionalProperties)
            {
                // Copy value from optional parms to the request.  They should have the same names and datatypes.
                System.Reflection.PropertyInfo piShared = (request.GetType()).GetProperty(property.Name);
				if (property.GetValue(optional, null) != null) // TODO Test that we do not add values for items that are null
					piShared.SetValue(request, property.GetValue(optional, null), null);
            }

            return request;
        }
    }
}